{"tagline":"The Static Kernel Analyzer (SKA)","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"SKA","google":"","body":"# What is SKA?\r\n\r\nThe _static kernel analyzer (SKA)_ combines a static, linear\r\npipeline simulator (similar to the IBM _spu\\_timing_ tool)\r\nwith architectural heuristics to model in-order\r\ninstruction issue and pipeline behavior.  Pipeline simulations take as\r\ninput the _intermediate representation (IR)_ from\r\n_Low-Level Virtual Machine (LLVM)_.\r\nLLVM and LLVM IR are adopted\r\nstandards in the HPC community,\r\nallowing SKA to support a wide range of source inputs.  SKA also has\r\nsupport for the upcoming OpenCL\r\n_Standard Portable Intermediate Representation (SPIR)_, which is\r\nbased on LLVM IR version 3.1.  Support for OpenCL kernel source\r\ninput (in the form of SPIR) allows SKA to model a rich variety of\r\nimportant modern computing architectures, and provides users with a\r\nnew paradigm for application optimization and design.\r\n\r\nThe underlying hardware properties accessed by SKA during pipeline\r\nsimulation are user-defined, allowing for both modeling of existing\r\nprocessors, and experimentation with novel resource provisioning.  Thus,\r\nSKA can be employed either as an analysis tool for code optimization, or\r\nas a co-design tool to aid in the creation of new processor\r\nconfigurations.\r\n\r\nUsers can visualize the output of SKA pipeline\r\nsimulations with the _skaview_ program.  The novel view representations in skaview give\r\nthe user both detailed clock-for-clock execution information, as well as\r\nintuitive _slope_ and _graph_ views for high-level detection of serious data\r\nand structural hazards.\r\n\r\n## Pipeline Simulator\r\n\r\nThe primary functionality of ska is as a pipeline simulator of LLVM IR.  The below image shows the an annotated screen shot from skaview:\r\n\r\n![Pipeline Simulation Detail](http://tuxfan.github.com/ska/images/pipeline.png)\r\n\r\nFrom left to right, this images shows the issue cycle of each instruction, the logic unit on which it executed (including multiple issue flags: D indicates dual-issue), the pipeline progress (dashes represent stalls) and the LLVM IR instruction that was executed.\r\n\r\n### Generating Simulations\r\n\r\nTo create output suitable for viewing in skaview, begin with the source file that you wish to analyze.  In this example, we use a simple _saxpy_ update:\r\n\r\n```C\r\nfor(i=0; i<N; ++i) {\r\n   y[i] = alpha*x[i] + y[i];\r\n} // for\r\n```\r\n\r\nUse the _skair_ script on your source file to generate LLVM IR:\r\n% skair saxpy.c\r\nThe _skair_ script is just a wrapper for one of the GNU compilers (gcc, g++ or gfortran) with added flags to use the [dragonegg](http://dragonegg.llvm.org) plugin, so you can add any flags that you need to compile your code, e.g.,\r\n% skair -O3 -I/usr/include/special -DMY_DEFINE=defined -Wall -msse saxpy.c\r\nwill just pass the extra flags onto the compiler.\r\n\r\nThe skair script outputs LLVM IR suitable for input into _ska_ (the actual simulator executable).  The IR looks like [this](http://tuxfan.github.com/ska/data/saxpy.ll).\r\n"}