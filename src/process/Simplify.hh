#ifndef Simplify_hh
#define Simplify_hh

#include <string>
#include <cstring>
#include <vector>
#include <list>
#include <algorithm>
#include <stack>

#include <llvm/IR/Module.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/Instruction.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/ADT/APInt.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Support/SourceMgr.h>
#include <llvm/IRReader/IRReader.h>
#include <llvm/IR/InstIterator.h>
#include <llvm/IR/CFG.h>

#include <FileIO.hh>
#include <Decode.hh>
#include <Instruction.hh>
#include <MachineState.hh>
#include <Statistics.hh>

#include <Dependency.hh>

#if defined(HAVE_GRAPHVIZ)
#include <Graphviz.hh>
#endif

#include <OpCodes.hh>
#include <OpTypes.hh>
#include <Core.hh>
#include <Utils.hh>
#include <RegisterSet.hh>


#include <TypeDefs.hh>


namespace ska {

class simplify_nodes {
  // simplify the interference table
  // generated by dataflow analysis

 private:
  std::stack<std::pair<llvm::Value *, bool>> simple_nodes;
  std::stack<std::pair<llvm::Value *, bool>> debug_nodes;
  // nodes < K degree are false
  // nodes > K degree are true
  // true means potential spill
  // false means no spill
  int K;

  // maximum degree allowed for a node
  // i.e. max number of colors

  // typedef int reg_type; //register type
  typedef int color;  // color
  // typedef int numPhys; //number of physical registers

  std::map<color, reg_type> color_map;
  // many-to-one mapping of
  // color to register type
  // eg : floating point, integer
  std::map<reg_type, numPhys> reg_map;
  // maps each regType to the number
  // of phys regs available
  // eg : there can be 10 fp regs
  // and 10 int regs
  // so it says how many colors
  // per register

 public:
  simplify_nodes(std::map<llvm::Value *, intf> intf_table,
                    register_set_t ** rs, size_t register_sets);

  void num_phys_regs(register_set_t **rs, size_t register_sets);

  std::stack<std::pair<llvm::Value *, bool>> getStack();

  std::map<reg_type, numPhys> get_reg_map();

  void populate_reg_map();

};

void simplify_nodes::populate_reg_map(){

   
}

std::stack<std::pair<llvm::Value *, bool>> simplify_nodes::getStack() {
  return simple_nodes;
}

std::map<reg_type, numPhys> simplify_nodes::get_reg_map() { return reg_map; }

void simplify_nodes::num_phys_regs( register_set_t **rs,
                                        size_t register_size){
                                        // change so that it gets this info from
                                        // regset

  for (int i=0; i<register_size; i++){
      register_set_t::register_type_t idx = rs[i]->type(); 
      reg_map[(int)idx] = (int)(rs[i]->num_registers());
  }

  reg_map[register_size] = 100;  //registers that do not belong 
                                //to the currently defined set
                                //are assigned from a large pool of 
                                //regs, this is a stopgap soln ...

  for (int i=0; i <register_size; i++){

      printf ("The register type %d has %d registers\n", i, reg_map[i]);
  }

  //reg_map[0] = 100;  // 0 is of int type and has 100 registers
  //reg_map[1] = 100;  // 1 is of float type and has another 100 registers
  //reg_map[2] = 200;
  // you get the idea ...

}

int getInstructionType(llvm::Value *instr) {
  auto type = ((llvm::Instruction *)instr)->getType();

  if (type->isIntegerTy()) {  // simple 2 type case
    return 0;  // can add more types
  } else if (type->isFloatTy()){
    return 1;
  } else if (type->isVectorTy()){
    return 2;
  } else {
    return 3;
  }
}

simplify_nodes::simplify_nodes(std::map<llvm::Value *, intf> intf_table,
                                    register_set_t ** rs, size_t register_sets) {

  // simplify the graph
  // by populating the stack
  // with simple/spill nodes

  num_phys_regs(rs, register_sets) ;  // gets data from reg set

  std::map<llvm::Value *, intf>::iterator it_0 = intf_table.begin() ;

  while (it_0 != intf_table.end()) {
    int degree = (it_0->second).size();
    int type = getInstructionType(it_0->first);
    if (degree > reg_map[type]) {  // change to correct reg type later
      // will be pulled in from register_set
      // header file
      std::pair<llvm::Value *, bool> t_pair =
          (std::make_pair(it_0->first, false));  // means
      simple_nodes.push(t_pair);  // not a simple node
      debug_nodes.push(t_pair);
    } else {
      std::pair<llvm::Value *, bool> t_pair =
          (std::make_pair(it_0->first, true));  // means
      simple_nodes.push(t_pair);  // is a simple node
      debug_nodes.push(t_pair);
    }
    it_0++;
  }

  // std::ofstream simple_igraph;
  // simple_igraph.open("simplified igraph");

  /*while (!debug_nodes.empty()){

            auto node = debug_nodes.top();
            debug_nodes.pop();

                    intf::iterator intf_it = intf_table[node.first].begin();
                    while(intf_it != intf_table[node.first].end()){
                              bool simp = node.second; //check whether
                                                    //simple node or not
                              std::string str_0;
                              llvm::raw_string_ostream rso_0(str_0);
                              rso_0<<*(intf_it->first);
                              simple_igraph << rso_0.str();

                              simple_igraph << " , ";

                              std::string str_1;
                              llvm::raw_string_ostream rso_1(str_1);
                              rso_1<<*(node.first);
                              simple_igraph << rso_1.str();

                              if (simp){
                                        simple_igraph << " T " ;//is simple
                                        simple_igraph << std::endl ;
                              }else{
                                        simple_igraph << " F " ;//is not simple
                                        simple_igraph << std::endl ;
                              }

                              intf_it++;
                    }
  } */

}

}  // namespace ska

#endif
