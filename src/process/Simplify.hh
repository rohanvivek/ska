namespace ska{

class simplify_nodes{

          //simplify the interference table
          //generated by dataflow analysis

private :  

          std::stack<std::pair<llvm::Value *, bool>> simple_nodes;
                          //nodes < K degree are false 
                          //nodes > K degree are true
                          //true means potential spill
                          //false means no spill
          int K; 

                 //maximum degree allowed for a node
                 //i.e. max number of colors


          typedef int reg_type; //register type
          typedef int color; //color

          std::map<color, reg_type> color_map;
                  //many-to-one mapping of 
                  //color to register type
                  //eg : floating point, integer
          std::map<reg_type, numPhys> reg_map; 
                 //maps each regType to the number
                 //of phys regs available
                 //eg : there can be 10 fp regs
                 //and 10 int regs
                 //so it says how many colors
                 //per register
                          
public :

          simplify_nodes(intf intf_table, dependency_map_t dmap);

};


simplify_nodes::simplify_nodes( std::map<llvm::Value *, intf> intf_table,
                                                 dependency_map_t dmap ){

          //simplify the graph
          //by populating the stack 
          //with simple/spill nodes

          intf::iterator it_0 = intf_table.begin();  
          while(it_0 != intf_table.end()){
                    int degree = (it_0->second).size();
                    if(degree > reg_map[0]){ //change to correct reg type later
                            pair<llvm::Value *,bool> t_pair;
                            t_pair.push_back( std::make_pair(it_0->first,false)); 
                            simple_nodes.push(t_pair); 
                    }else{
                            pair<llvm::Value *,bool> t_pair;
                            t_pair.push_back( std::make_pair(it_0->first,true)); 
                            simple_nodes.push(t_pair); 
                    }
                    it_0++;
          }
}


}
