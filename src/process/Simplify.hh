#ifndef Simplify_hh
#define Simplify_hh

#include <string>
#include <cstring>
#include <vector>
#include <list>

#include <llvm/IR/Module.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/Instruction.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/ADT/APInt.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Support/SourceMgr.h>
#include <llvm/IRReader/IRReader.h>
#include <llvm/IR/InstIterator.h>
#include <llvm/IR/CFG.h>

#include <FileIO.hh>
#include <Decode.hh>
#include <Instruction.hh>
#include <MachineState.hh>
#include <Statistics.hh>

#include <Dependency.hh>

#if defined(HAVE_GRAPHVIZ)
#include <Graphviz.hh>
#endif

#include <OpCodes.hh>
#include <OpTypes.hh>
#include <Core.hh>
#include <Utils.hh>
#include <algorithm>
#include <stack>

#include <TypeDefs.hh>


namespace ska{

class simplify_nodes{

          //simplify the interference table
          //generated by dataflow analysis

private :  


          std::stack<std::pair<llvm::Value *, bool>> simple_nodes;
          std::stack<std::pair<llvm::Value *, bool>> debug_nodes;
                          //nodes < K degree are false 
                          //nodes > K degree are true
                          //true means potential spill
                          //false means no spill
          int K;

                 //maximum degree allowed for a node
                 //i.e. max number of colors


          //typedef int reg_type; //register type
          typedef int color; //color
          //typedef int numPhys; //number of physical registers

          std::map<color, reg_type> color_map;
                  //many-to-one mapping of 
                  //color to register type
                  //eg : floating point, integer
          std::map<reg_type, numPhys> reg_map; 
                 //maps each regType to the number
                 //of phys regs available
                 //eg : there can be 10 fp regs
                 //and 10 int regs
                 //so it says how many colors
                 //per register
           
                          
public :

          simplify_nodes(std::map<llvm::Value *, intf> intf_table);

          void num_phys_regs();

          std::stack<std::pair<llvm::Value *, bool>> getStack();

          std::map<reg_type, numPhys> get_reg_map();

};

std::stack<std::pair<llvm::Value *, bool>> simplify_nodes::getStack(){
          return simple_nodes;
}

std::map<reg_type,numPhys> simplify_nodes::get_reg_map(){

          return reg_map;

}

void simplify_nodes::num_phys_regs(){ //change so that it gets this info from regset

          reg_map[0]=100; //0 is of int type and has 100 registers
          reg_map[1]=100; //1 is of float type and has another 100 registers 
                          //you get the idea ...

}

int getInstructionType( llvm::Value * instr ){

        auto type = ((llvm::Instruction *)instr)->getType();

            if ( type->isIntegerTy()){ //simple 2 type case
                      return 0;        //can add more types
            }else{
                      return 1;
            }
}


simplify_nodes::simplify_nodes( std::map<llvm::Value *, intf> intf_table
                                                  ){
          //simplify the graph
          //by populating the stack
          //with simple/spill nodes

          num_phys_regs(); //gets data from reg set

          std::map<llvm::Value *,intf>::iterator it_0 = intf_table.begin();

          while(it_0 != intf_table.end()){
                    int degree = (it_0->second).size();
                    int type = getInstructionType(it_0->first );
                    if(degree > reg_map[type]){ //change to correct reg type later
                                             //will be pulled in from register_set
                                             //header file
                            std::pair<llvm::Value *,bool> t_pair
                                =( std::make_pair(it_0->first,false)); //means
                            simple_nodes.push(t_pair); //not a simple node
                            debug_nodes.push(t_pair);
                    }else{
                            std::pair<llvm::Value *,bool> t_pair
                               =( std::make_pair(it_0->first,true)); //means
                            simple_nodes.push(t_pair); //is a simple node
                            debug_nodes.push(t_pair);
                    }
                    it_0++;
          }

          std::ofstream simple_igraph;
          simple_igraph.open("simplified igraph");
          
          while (!debug_nodes.empty()){

                    auto node = debug_nodes.top();
                    debug_nodes.pop();

                            intf::iterator intf_it = intf_table[node.first].begin();  
                            while(intf_it != intf_table[node.first].end()){
                                      bool simp = node.second; //check whether   
                                                            //simple node or not 
                                      std::string str_0;
                                      llvm::raw_string_ostream rso_0(str_0);
                                      rso_0<<*(intf_it->first);
                                      simple_igraph << rso_0.str();

                                      simple_igraph << " , ";
                                      
                                      std::string str_1;
                                      llvm::raw_string_ostream rso_1(str_1);
                                      rso_1<<*(node.first);
                                      simple_igraph << rso_1.str();
    
                                      if (simp){
                                                simple_igraph << " T " ;//is simple
                                                simple_igraph << std::endl ;
                                      }else{
                                                simple_igraph << " F " ;//is not simple
                                                simple_igraph << std::endl ;
                                      }
 
                                      intf_it++; 
                            }
          } 
}

} //namespace ska

#endif
